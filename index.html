<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Diesel &amp; Wundergraph Workshop</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@3.9.2//css/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@3.9.2//css/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@3.9.2//css/theme/beige.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'https://unpkg.com/reveal.js@3.9.2//css/print/pdf.css' : 'https://unpkg.com/reveal.js@3.9.2//css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="https://unpkg.com/reveal.js@3.9.2//lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section id="wundergraph-or-how-to-build-a-compile-time-graphql-orm-using-diesel" class="slide level2">
<h2>Wundergraph or How to build a compile time GraphQL ORM using Diesel</h2>
</section>
<section><section id="introduction" class="title-slide slide level1"><h1>Introduction</h1></section>
<section id="additional-information" class="slide level2">
<h2>Additional information</h2>
<ul>
<li>Workshop was part of the RustFest 2019 in Barcelona</li>
<li>See speaker notes (Press <code>S</code>) for additional information</li>
</ul>
</section>
<section id="about-me" class="slide level2">
<h2>About me</h2>
<ul>
<li>Writing rust since 2014</li>
<li>weiznich at github</li>
<li>Maintainer of Diesel and creator of Wundergraph</li>
</ul>
<aside class="notes">
<ul>
<li>First time doing such a workshop, so don’t know how it will work out</li>
<li>So if you have any feedback I would be happy</li>
</ul>
</aside>
</section>
<section id="general-rules" class="slide level2">
<h2>General rules</h2>
<ul>
<li>Ask Questions</li>
<li>Interrupt me if you don’t understand something or want to know more</li>
</ul>
<aside class="notes">

</aside>
</section>
<section id="outline" class="slide level2">
<h2>Outline</h2>
<ul>
<li>Today:
<ol type="1">
<li>Diesel introduction</li>
<li>Diesel internals</li>
</ol></li>
<li>Tomorrow:
<ol start="3" type="1">
<li>Wundergraph introduction</li>
<li>Wundergraph internals</li>
</ol></li>
</ul>
<aside class="notes">
<h3 id="diesel-introduction">Diesel introduction</h3>
<p>Talk about diesel in general</p>
<p>after that a simple exercise building a simple CRUD like application</p>
<section id="diesel-internals" class="slide level2">
<h2>Diesel internals</h2>
<ul>
<li>Talk about diesel internals, specifically how compile time validation is done</li>
<li>Mention a few limitations of that approach</li>
<li>A few words on how to extend diesel</li>
</ul>
<p>after that an exercise how to extend diesel by implementing a custom type and write some generic flexible code.</p>
</section>
<section id="wundergraph-introduction" class="slide level2">
<h2>Wundergraph introduction</h2>
<p>What is wundergraph, how does a simple wundergraph usage look like (At that point: What is GraphQL?)</p>
<p>after that an small exercise on how to build a simple GraphQL API using diesel, juniper and wundergraph</p>
</section>
<section id="wundergraph-internals" class="slide level2">
<h2>Wundergraph internals</h2>
<p>Take a look at some internal wundergraph code. How does wundergraph generate all those things for you</p>
<p>A final exercise on how to implement some advanced custom entity implementations.</p>
</section>
</aside>
</section></section>
<section><section id="diesel" class="title-slide slide level1"><h1>Diesel</h1></section>
<section id="what-is-diesel" class="slide level2">
<h2>What is diesel</h2>
<ul>
<li>Diesel is a query builder with some ORM like features</li>
<li>Provides the following building blocks:
<ul>
<li>Abstract database interfaces to execute queries</li>
<li>Functionality to map query results to rust structs</li>
<li>Functionality to map rust structs to query results</li>
<li>A query dsl that could be used to construct compile time checked sql queries</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Officially Supported Backends: PostgreSQL, SQLite, Mysq, Unofficially Oracle (as third party crate)</li>
<li>Note that mapping from and to rust are separate things by design. Mention REST Api as an example.</li>
<li>Talk about how the internals of how checking works later today</li>
</ul>
</aside>
</section>
<section id="what-is-diesel-1" class="slide level2">
<h2>What is diesel</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">table!</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    students <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>        id -&gt; Integer,</span>
<span id="cb1-4"><a href="#cb1-4"></a>        name -&gt; Text,</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="op">}</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="at">#[</span>derive<span class="at">(</span>Queryable<span class="at">)]</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb1-11"><a href="#cb1-11"></a>    name: <span class="dt">String</span>,</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="kw">let</span> students: <span class="dt">Vec</span>&lt;Student&gt; =</span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="pp">students::</span>table</span>
<span id="cb1-16"><a href="#cb1-16"></a>        .filter(<span class="pp">students::</span>id.eq(<span class="dv">42</span>))</span>
<span id="cb1-17"><a href="#cb1-17"></a>        .<span class="pp">load::</span>&lt;Student&gt;(&amp;conn)?;</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="pp">diesel::</span>insert_into(<span class="pp">students::</span>table)</span>
<span id="cb1-20"><a href="#cb1-20"></a>    .values((</span>
<span id="cb1-21"><a href="#cb1-21"></a>        <span class="pp">students::</span>id.eq(<span class="dv">43</span>),</span>
<span id="cb1-22"><a href="#cb1-22"></a>        <span class="pp">students::</span>name.eq(<span class="st">&quot;weiznich&quot;</span>),</span>
<span id="cb1-23"><a href="#cb1-23"></a>    )).execute(&amp;conn)?;</span></code></pre></div>
<aside class="notes">
<ul>
<li>Separates schema definition and “model”</li>
<li>No real model, separated functionality for insert, query, update and delete</li>
<li>Data mapping between query result and rust types</li>
<li>Talk about each of those steps later</li>
</ul>
</aside>
</section>
<section id="diesel-features" class="slide level2">
<h2>Diesel features</h2>
<p>General design assumptions for diesel:</p>
<ul>
<li>Diesel does not own the database</li>
<li>SQL database implementations are different, Diesel should not try to abstract away those differences</li>
<li>Rust has a strong static type system, try to use that for correctness and performance</li>
<li>There is a distinction between Rust types and SQL types.</li>
</ul>
<aside class="notes">
<ul>
<li>Diesel should work with newly created databases and with existing ones</li>
<li>Diesel should allow to write optimized SQL for each backend without big problems/hacks</li>
<li>Type checking queries + performance optimizations</li>
<li>One rust type could map to multiple SQL types and vice versa
<ul>
<li>Example: Mapping to (<code>String</code>) and from (<code>str</code> + <code>String</code>) Strings</li>
</ul></li>
</ul>
</aside>
</section>
<section id="creating-a-diesel-application" class="slide level2">
<h2>Creating a diesel application</h2>
<ol start="0" type="1">
<li>Install <code>diesel_cli</code> (A tool to manage migrations/your schema)</li>
<li>Setup the database using SQL migrations</li>
<li>Create a rust schema file form your database</li>
<li>Write code interacting with the database</li>
</ol>
<aside class="notes">
<ul>
<li>First step not actually required, depending on your use case. For example not required for big existing schema, where you only want to access a single table</li>
<li>Second step not required for existing databases</li>
<li>Use the next few slides to cover each of those steps in more details</li>
</ul>
</aside>
</section>
<section id="diesel-cli" class="slide level2">
<h2>Diesel CLI</h2>
<ul>
<li>Small helper cli tool for Diesel</li>
<li>Provides:
<ul>
<li>a way to manage a database (setup/reset)</li>
<li>a way to manage migrations (create/apply/undo)</li>
<li>a way to generate Rust schema code from existing databases</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Technically not required to use diesel, but makes things easier</li>
<li>There is also a crate (<code>diesel_migrations</code>) avaible to apply migrations at program runtime instead of manually</li>
<li>Technical note: Depending on the enabled features native database libraries are required. Backends controlled by cargos feature flags, by default postgresql, sqlite and mysql</li>
</ul>
</aside>
</section>
<section id="the-table-marco" class="slide level2">
<h2>The <code>table!</code> marco</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">table!</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>    students(id) <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>        id -&gt; Integer,</span>
<span id="cb2-4"><a href="#cb2-4"></a>        name -&gt; Text,</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="op">}</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>Defines a database schema on rust side</li>
<li>Generates a bunch of helper types used to construct queries</li>
</ul>
<aside class="notes">
<ul>
<li>Generates helper types used for type checking queries at compile time</li>
<li>Now just a overview what’s the meaning of the macro and how to use it</li>
<li>We will look at the generated code later today</li>
<li>Use SQL types as column types</li>
<li>Basically defines a module <code>students</code> with the following content:
<ul>
<li>An unit struct named <code>table</code> representing the table</li>
<li>An unit struct for each column</li>
<li>A submodul named <code>dsl</code> containing reexports for each column and the <code>table</code> as <code>table_name</code></li>
</ul></li>
</ul>
</aside>
</section>
<section id="select-statements" class="slide level2">
<h2>Select statements</h2>
<ul>
<li>Diesel provides a query DSL to construct statically known queries</li>
<li>Generally speaking: DSL maps quite literally to the generated SQL</li>
<li>Documentation mostly available on the <code>QueryDsl</code> trait</li>
</ul>
<div class="fragment">
<p>Basic structure of a query:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">a_table::</span>table</span>
<span id="cb3-2"><a href="#cb3-2"></a>    .select(fields_to_select)</span>
<span id="cb3-3"><a href="#cb3-3"></a>    .filter(some_filter_expression)</span>
<span id="cb3-4"><a href="#cb3-4"></a>    .order_by(some_order_expression)</span>
<span id="cb3-5"><a href="#cb3-5"></a>    .limit(limit_as_i64)</span>
<span id="cb3-6"><a href="#cb3-6"></a>    .offset(offset_as_i64)</span>
<span id="cb3-7"><a href="#cb3-7"></a>    .<span class="pp">load::</span>&lt;SomeStructOrTuple&gt;(&amp;conn);</span></code></pre></div>
<aside class="notes">
<ul>
<li><p>We will talk about the simple cases first</p></li>
<li><p>Means: We have a statically known select statement</p></li>
<li><p>For the general case: To many possibilities, so we just cover some examples and give a guideline how to find things in our docs</p></li>
<li><p>General advice for finding things in our docs: Search for the SQL expression you want to write</p></li>
<li><p>Notably exception: <code>IN</code> which is generated by <code>.eq_any</code> instead (because keyword)</p></li>
<li><p>Each clause is optional, if not given some default is assumed (Same as in SQL)</p></li>
<li><p>We will talk about each part in the next few slides, while mentioning a few common errors</p></li>
<li><p>order of the methods does not matter</p></li>
<li><p>Talk about select, filter and order in the next few slides</p></li>
<li><p><code>limit</code>/<code>offset</code> just takes a <code>i64</code> number</p></li>
</ul>
</aside>
</div>
</section>
<section id="select-statements-select-clause" class="slide level2">
<h2>Select statements (Select clause)</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1"></a><span class="pp">a_table::</span>table.select((</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="pp">a_table::</span>column_a, <span class="co">// just select a column</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="pp">a_table::</span>column_b + <span class="pp">a_table::</span>column_b, <span class="co">// an expression</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="st">&quot;abc&quot;</span>.<span class="pp">into_sql::</span>&lt;Text&gt;() <span class="co">// or a constant</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>))</span></code></pre></div>
<ul>
<li>Just a tuple of expressions that should appear in the select clause</li>
<li>If not given just select the columns of the table in the order given by the <code>table!</code> macro</li>
</ul>
<aside class="notes">
<ul>
<li>Currently not supported: Mixing aggregate and none aggregate select expressions (<code>Max</code>/<code>Count</code>/<code>SUM</code>/… )</li>
</ul>
</aside>
</section>
<section id="select-statements-where-clause" class="slide level2">
<h2>Select statements (Where clause)</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1"></a><span class="pp">a_table::</span>table</span>
<span id="cb5-2"><a href="#cb5-2"></a>    .filter(<span class="pp">a_table::</span>column_a.eq(foo)</span>
<span id="cb5-3"><a href="#cb5-3"></a>        .and(<span class="pp">a_table::</span>column_b.like(baz)))</span>
<span id="cb5-4"><a href="#cb5-4"></a>    .or_filter(<span class="pp">a_table::</span>column_c.is_null())</span></code></pre></div>
<ul>
<li>Constructs a where clause of the current SQL select statement</li>
<li>If not given no where clause is generated</li>
<li>Calling <code>.filter</code> twice appends the new where clause with an <code>AND</code> to the old one</li>
<li>See docs <code>*ExpressionMethods</code> traits for methods useful to construct inner expressions</li>
</ul>
<aside class="notes">

</aside>
</section>
<section id="select-statement-order-clause" class="slide level2">
<h2>Select statement (Order clause)</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">a_table::</span>table.order_by((</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="pp">a_table::</span>column_a.asc(),</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="pp">a_table::</span>column.desc()</span>
<span id="cb6-4"><a href="#cb6-4"></a>))</span></code></pre></div>
<ul>
<li>Creates a order clause</li>
<li>Possibility to single order expression or multiple as tuple</li>
<li>Default sorting order: <code>ASC</code></li>
<li>If clause not given no order clause is generated</li>
</ul>
<aside class="notes">
<ul>
<li>Calling this twice will override the existing order clause</li>
<li>(Use <code>then_order_by</code> to append to existing clause)</li>
</ul>
</aside>
</section>
<section id="result-mapping-queryable" class="slide level2">
<h2>Result mapping (<code>Queryable</code>)</h2>
<ul>
<li>A trait that indicates that a given rust type could be the result of a query with a SQL type</li>
<li>Provided custom derive, mapping is done by order, <strong>not by name</strong></li>
<li>Default implementations for tuples</li>
</ul>
<aside class="notes">
<ul>
<li>Custom derive assumes:
<ul>
<li>Field order</li>
<li>All field types are types that are supported by diesel (look into custom types later)</li>
</ul></li>
<li>Field order</li>
<li>That’s not a model, that’s the result of a <code>Query</code>!</li>
<li>One struct implementing <code>Queryable</code> != one table.</li>
<li>Multiple tables/queries could use the same struct.</li>
<li>Fields of multiple tables could appear in the same query</li>
</ul>
</aside>
</section>
<section id="query-execution" class="slide level2">
<h2>Query execution</h2>
<ul>
<li>Different ways to execute a query:
<ul>
<li><code>load::&lt;U&gt;</code>/<code>get_results::&lt;U&gt;</code>: Returns a list of <code>U</code></li>
<li><code>get_result::&lt;U&gt;</code>: Returns the first <code>U</code> ignores the rest</li>
<li><code>first::&lt;U&gt;</code>: Returns the first <code>U</code>, attaches a <code>LIMIT 1</code> clause to the executed query</li>
<li><code>execute</code>: Returns the number of affected columns</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Where <code>U</code> is a type that implements <code>Queryable</code></li>
</ul>
</aside>
</section>
<section id="insert-statements" class="slide level2">
<h2>Insert statements</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1"></a><span class="pp">diesel::</span>insert_into(<span class="pp">a_table::</span>table)</span>
<span id="cb7-2"><a href="#cb7-2"></a>    .values((</span>
<span id="cb7-3"><a href="#cb7-3"></a>        <span class="pp">a_table::</span>column_a.eq(value),</span>
<span id="cb7-4"><a href="#cb7-4"></a>        <span class="pp">a_table::</span>column_b.eq(other_value)</span>
<span id="cb7-5"><a href="#cb7-5"></a>)).execute(&amp;conn);</span></code></pre></div>
<ul>
<li>Creates a <code>INSERT INTO</code> statement.</li>
</ul>
<aside class="notes">
<ul>
<li>values passed as tuple</li>
<li>possible to pass a slice/vec of tuples for batch insert</li>
<li>possible to use a struct with named fields instead of a anonymous tuple</li>
</ul>
</aside>
</section>
<section id="insert-statements-1" class="slide level2">
<h2>Insert statements</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1"></a><span class="at">#[</span>derive<span class="at">(</span>Insertable<span class="at">)]</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;students&quot;</span><span class="at">]</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">struct</span> NewStudent <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb8-5"><a href="#cb8-5"></a>    name: <span class="dt">String</span>,</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="op">}</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="pp">diesel::</span>insert_into(<span class="pp">students::</span>table)</span>
<span id="cb8-9"><a href="#cb8-9"></a>    .values(&amp;<span class="op">[</span>new_student_1, new_student_2<span class="op">]</span>)</span>
<span id="cb8-10"><a href="#cb8-10"></a>    .execute(&amp;conn);</span></code></pre></div>
<aside class="notes">
<ul>
<li>Possibility to use a struct to structure the insert data</li>
<li>Possibility to use such struct as tuple element as shown in the example before</li>
<li>Possibility to perform a batch insert by passing a slice of elements to the <code>values</code> function</li>
<li>Preferred way if struct already exists (<code>Deserialize</code>), otherwise use tuple variant</li>
<li>Additional methods for <code>upsert</code>, <code>returing</code> clauses, <code>replace_into</code> and inserts from select statements are provided. See the documentation of <code>diesel::insert_into</code> and <code>InsertStatement</code> for details</li>
</ul>
</aside>
</section>
<section id="update-statements" class="slide level2">
<h2>Update statements</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1"></a><span class="pp">diesel::</span>update(<span class="pp">a_table::</span>table.filter(<span class="pp">a_table::</span>id.eq(<span class="dv">1</span>)))</span>
<span id="cb9-2"><a href="#cb9-2"></a>    .set((</span>
<span id="cb9-3"><a href="#cb9-3"></a>        <span class="pp">a_table::</span>column_a.eq(some_value),</span>
<span id="cb9-4"><a href="#cb9-4"></a>        <span class="pp">a_table::</span>column_b.eq(<span class="pp">a_table::</span>column_b + <span class="dv">5</span>.<span class="pp">into_sql::</span>&lt;Integer&gt;())</span>
<span id="cb9-5"><a href="#cb9-5"></a>    )).execute(&amp;conn);</span></code></pre></div>
<ul>
<li>Creates a <code>UPDATE</code> statement</li>
<li>Similar to insert statements, there is a tuple variant and a variant with a struct</li>
</ul>
<aside class="notes">
<ul>
<li><code>filter</code> just maps to a <code>UPDATE a_table SET … WHERE …</code> statement</li>
<li><code>filter</code> clause optional, leaving it off will update all entries in a given table</li>
<li>Struct variant will be shown on the next slide</li>
</ul>
</aside>
</section>
<section id="update-statements-1" class="slide level2">
<h2>Update statements</h2>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1"></a><span class="at">#[</span>derive<span class="at">(</span>AsChangeset<span class="at">,</span> Identifiable<span class="at">)]</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;students&quot;</span><span class="at">]</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">struct</span> ChangeStudent <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb10-5"><a href="#cb10-5"></a>    name: Text,</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="kw">let</span> changed_student: ChangeStudent = get_changed_student();</span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="pp">diesel::</span>update(&amp;changed_student)</span>
<span id="cb10-11"><a href="#cb10-11"></a>    .set(&amp;changed_student).execute(&amp;conn);</span></code></pre></div>
<aside class="notes">
<ul>
<li>Preferred variant when data structure for changeset already exists</li>
<li><code>AsChangeset</code> says that a struct could be used a in a <code>UPDATE</code> statement as set clause</li>
<li><code>Identifiable</code> says that a struct represents some existing database entry
<ul>
<li>Useful for update and delete</li>
<li>Only required if struct is also passed to update</li>
<li>Default primary key name: <code>id</code>, use the <code>#[primary_key(your_key)]</code> attribute to change that</li>
<li>Primary key field ignored for updating the value. Used to build where clause</li>
</ul></li>
<li>Possible to mix tuple and struct similar to insert statements in set clause</li>
<li>normally options decided if field is updated or not</li>
<li><code>[changeset_options(treat_none_as_null="true")]</code></li>
</ul>
</aside>
</section>
<section id="delete-statements" class="slide level2">
<h2>Delete statements</h2>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1"></a><span class="pp">diesel::</span>delete(</span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="pp">a_table::</span>table.filter(filter_expression)</span>
<span id="cb11-3"><a href="#cb11-3"></a>).execute(&amp;conn)<span class="ch">&#39;</span></span></code></pre></div>
<ul>
<li>Creates a <code>DROP FROM a_table</code> statement</li>
</ul>
<aside class="notes">
<ul>
<li><code>filter</code> just maps to a <code>DROP FROM a_table WHERE …</code> statement</li>
<li><code>filter</code> clause optional, leaving it off will delete all entries in a given table</li>
<li>Also possible to use a struct implementing <code>Identifiable</code> instead of table + optional filter</li>
</ul>
</aside>
</section>
<section id="raw-sql-queries" class="slide level2">
<h2>Raw SQL queries</h2>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1"></a><span class="at">#[</span>derive<span class="at">(</span>QueryableByName<span class="at">)]</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;students&quot;</span><span class="at">]</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb12-5"><a href="#cb12-5"></a>    name: <span class="dt">String</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="op">}</span></span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="pp">diesel::</span>sql_query(<span class="st">&quot;SELECT id, name FROM students WHERE name = $1&quot;</span>)</span>
<span id="cb12-9"><a href="#cb12-9"></a>    .<span class="pp">bind::</span>&lt;Text, _&gt;(<span class="st">&quot;weiznich&quot;</span>)</span>
<span id="cb12-10"><a href="#cb12-10"></a>    .load(&amp;conn);</span></code></pre></div>
<ul>
<li>Raw SQL query interface</li>
<li>Meant to be used when the query DSL is missing some expressions or failed to express something complex</li>
</ul>
<aside class="notes">
<ul>
<li>We’ve seen parts of the dsl</li>
<li>Sometimes the dsl is missing something, for such cases (or if you don’t like the dsl), there is a raw sql interfaces</li>
<li>That’s part of diesel and you should use, it’s an API as everything else.</li>
<li><code>QueryableByName</code> is similar to <code>Queryable</code> but does the mapping based on field names instead of field order
<ul>
<li>Use aliases to get unique names</li>
<li>There are multiple attributes for
<ul>
<li><code>#[table_name]</code> (saying that the struct matches a given table)</li>
<li><code>#[column_name]</code> changing the name of the column, otherwise field name is used</li>
<li><code>#[sql_type]</code> Specifying the sql type of a field explicitly (only required if <code>#[table_name]</code> is not used)</li>
</ul></li>
</ul></li>
<li>Different bind syntax per backend</li>
</ul>
</aside>
</section>
<section id="complex-queries" class="slide level2">
<h2>“Complex” queries</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1"></a><span class="pp">table!</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>    students <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>        id -&gt; Integer,</span>
<span id="cb13-4"><a href="#cb13-4"></a>        name -&gt; Text,</span>
<span id="cb13-5"><a href="#cb13-5"></a>        supervisor -&gt; Integer,</span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="op">}</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="pp">table!</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>    teachers <span class="op">{</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>        id -&gt; Integer,</span>
<span id="cb13-12"><a href="#cb13-12"></a>        name -&gt; Text,</span>
<span id="cb13-13"><a href="#cb13-13"></a>    <span class="op">}</span></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="op">}</span></span>
<span id="cb13-15"><a href="#cb13-15"></a></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="pp">allow_tables_to_appear_in_same_query!</span>(students, teachers);</span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="pp">joinable!</span>(students -&gt; teachers (supervisor));</span></code></pre></div>
<aside class="notes">
<ul>
<li>Example a bit longer, multiple slides</li>
<li>This one just defines the schema, saying that there are two tables with 1:n relation between them</li>
<li>We want to write a query returning all teachers with a list of their students</li>
<li>Talk about different approaches</li>
</ul>
</aside>
</section>
<section id="complex-queries-naive-way" class="slide level2">
<h2>“Complex” queries (naive way)</h2>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">let</span> teachers = <span class="pp">teachers::</span>table.<span class="pp">load::</span>&lt;Teacher&gt;(&amp;conn)?;</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">let</span> teacher_and_students: <span class="dt">Vec</span>&lt;(Teacher, <span class="dt">Vec</span>&lt;Student&gt;)&gt; =</span>
<span id="cb14-4"><a href="#cb14-4"></a>    teachers.into_iter()</span>
<span id="cb14-5"><a href="#cb14-5"></a>        .map(|teacher| <span class="op">{</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>            <span class="kw">let</span> students = <span class="pp">students::</span>table</span>
<span id="cb14-7"><a href="#cb14-7"></a>                .filter(<span class="pp">students::</span>supervisor.eq(teacher.id))</span>
<span id="cb14-8"><a href="#cb14-8"></a>                .<span class="pp">load::</span>&lt;Student&gt;(&amp;conn)?;</span>
<span id="cb14-9"><a href="#cb14-9"></a>            <span class="cn">Ok</span>((teacher, students))</span>
<span id="cb14-10"><a href="#cb14-10"></a>        <span class="op">}</span>).collect()?;</span></code></pre></div>
<aside class="notes">
<ul>
<li><p>What is the problem with that approach?</p></li>
<li><p>How could we do that better?</p></li>
<li><p>N + 1 Query problem, does not scale well</p></li>
</ul>
</aside>
</section>
<section id="complex-queries-joins" class="slide level2">
<h2>“Complex” queries (joins)</h2>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1"></a><span class="pp">teachers::</span>table.inner_join(<span class="pp">students::</span>table)</span>
<span id="cb15-2"><a href="#cb15-2"></a>    .<span class="pp">load::</span>&lt;(Teacher, Student)&gt;(&amp;conn);</span></code></pre></div>
<aside class="notes">
<ul>
<li>Better?</li>
<li>Possible “problems”
<ul>
<li>Loads each teacher once fore each student</li>
<li>Data structure does not really match that what we want -&gt; Need to reorganize data</li>
</ul></li>
</ul>
</aside>
</section>
<section id="complex-queries-associations" class="slide level2">
<h2>“Complex” queries (associations)</h2>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1"></a><span class="at">#[</span>derive<span class="at">(</span>Identifiable<span class="at">,</span> Queryable<span class="at">)]</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;teachers&quot;</span><span class="at">]</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">struct</span> Teacher <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb16-5"><a href="#cb16-5"></a>    name: <span class="dt">String</span>,</span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="op">}</span></span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="at">#[</span>derive<span class="at">(</span>Identifiable<span class="at">,</span> Queryable<span class="at">,</span> Associations<span class="at">)]</span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="at">#[</span>belongs_to<span class="at">(</span>Teacher<span class="at">,</span> foreign_key <span class="at">=</span> <span class="st">&quot;supervisor&quot;</span><span class="at">)]</span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;students&quot;</span><span class="at">]</span></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb16-13"><a href="#cb16-13"></a>    name: <span class="dt">String</span>,</span>
<span id="cb16-14"><a href="#cb16-14"></a>    supervisor: <span class="dt">i32</span></span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="op">}</span></span>
<span id="cb16-16"><a href="#cb16-16"></a></span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="kw">let</span> teachers = <span class="pp">teachers::</span>table.<span class="pp">load::</span>&lt;Teacher&gt;(&amp;conn)?;</span>
<span id="cb16-18"><a href="#cb16-18"></a></span>
<span id="cb16-19"><a href="#cb16-19"></a><span class="kw">let</span> students = <span class="pp">Student::</span>belonging_to(&amp;teachers)</span>
<span id="cb16-20"><a href="#cb16-20"></a>    .<span class="pp">load::</span>&lt;Student&gt;(&amp;conn)?</span>
<span id="cb16-21"><a href="#cb16-21"></a>    .grouped_by(&amp;teachers);</span>
<span id="cb16-22"><a href="#cb16-22"></a></span>
<span id="cb16-23"><a href="#cb16-23"></a><span class="kw">let</span> teachers_with_students = teachers.into_iter()</span>
<span id="cb16-24"><a href="#cb16-24"></a>    .zip(students)</span>
<span id="cb16-25"><a href="#cb16-25"></a>    .<span class="pp">collect::</span>&lt;<span class="dt">Vec</span>&lt;(Teacher, <span class="dt">Vec</span>&lt;Student&gt;)&gt;&gt;();</span></code></pre></div>
<aside class="notes">
<ul>
<li>Use two queries to load all data
<ul>
<li>Fixed number of queries for all records -&gt; no N + 1 problem</li>
</ul></li>
<li>Normaly faster than using one joined query because has less data duplication (depends on your data)</li>
<li>Second query is basically <code>SELECT * FROM students WHERE supervisor IN (id_list)</code>
<ul>
<li>Technically that’s a normal diesel query, therefore you could just add normal <code>QueryDsl</code> function calls</li>
</ul></li>
<li>Grouping is done on application side, but that’s normally faster than calling the database again</li>
</ul>
</aside>
</section>
<section id="common-errors" class="slide level2">
<h2>Common Errors</h2>
<ul>
<li>Diesel uses the type system to check if
<ul>
<li>a query generates valid SQL</li>
<li>a query result matches the structure of the output</li>
<li>matching field types are compatible with given query types</li>
</ul></li>
<li>Some of those mistakes result in rather long error messages</li>
<li>Most of them have a structure that helps you to find the actual problem</li>
</ul>
<aside class="notes">
<ul>
<li><p>from clause contains table of selected fields</p></li>
<li><p>Give a example for each on the next few slides</p></li>
<li><p>Generally speaking: Getting an error that some diesel trait is not implemented for some diesel type mostly means that you’ve done something that would result in an invalid query or an incompatible type mapping</p></li>
</ul>
</aside>
</section>
<section id="common-errors-invalid-sql" class="slide level2">
<h2>Common Errors (Invalid SQL)</h2>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1"></a><span class="pp">students::</span>table.select(<span class="pp">teachers::</span>name).<span class="pp">load::</span>&lt;Student&gt;(&amp;conn);</span></code></pre></div>
<pre><code>error[E0277]: the trait bound `teachers::columns::name: diesel::SelectableExpression&lt;students::table&gt;` is not satisfied
  --&gt; src/main.rs:30:21
   |
30 |     students::table.select(teachers::name).load::&lt;Student&gt;(&amp;conn);
   |                     ^^^^^^ the trait `diesel::SelectableExpression&lt;students::table&gt;` is not implemented for `teachers::columns::name`
   |
   = help: the following implementations were found:</code></pre>
<aside class="notes">
<ul>
<li>Trying to select a column from a other table</li>
<li>Error message pointing to the concrete problem and telling you that it is not possible to select the column from the other table</li>
</ul>
</aside>
</section>
<section id="common-errors-result-missmatch" class="slide level2">
<h2>Common Errors (Result missmatch)</h2>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1"></a><span class="at">#[</span>derive<span class="at">(</span>Queryable<span class="at">)]</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb19-4"><a href="#cb19-4"></a>    name: <span class="dt">String</span></span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="op">}</span></span>
<span id="cb19-6"><a href="#cb19-6"></a></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">let</span> s: <span class="dt">Vec</span>&lt;Student&gt; = <span class="pp">students::</span>table</span>
<span id="cb19-8"><a href="#cb19-8"></a>    .select(<span class="pp">students::</span>id)</span>
<span id="cb19-9"><a href="#cb19-9"></a>    .load(conn);</span></code></pre></div>
<pre><code>error[E0277]: the trait bound `(std::string::String, i32): diesel::Queryable&lt;diesel::sql_types::Integer, diesel::pg::Pg&gt;` is not satisfied
  --&gt; src/main.rs:34:64
   |
34 |     let s: Vec&lt;Student&gt; = students::table.select(students::id).load(&amp;conn)?;
   |                                                                ^^^^ the trait `diesel::Queryable&lt;diesel::sql_types::Integer, diesel::pg::Pg&gt;` is not implemented for `(std::string::String, i32)`</code></pre>
<aside class="notes">
<ul>
<li>Error mentions that the query returns one field (<code>Queryable</code>) whereas the result type as two types (tuple).</li>
</ul>
</aside>
</section>
<section id="common-errors-type-missmatch" class="slide level2">
<h2>Common Errors (Type missmatch)</h2>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">let</span> s: <span class="dt">Vec</span>&lt;<span class="dt">String</span>&gt; = <span class="pp">students::</span>table</span>
<span id="cb21-2"><a href="#cb21-2"></a>    .select(<span class="pp">students::</span>id)</span>
<span id="cb21-3"><a href="#cb21-3"></a>    .load(conn);</span></code></pre></div>
<pre><code>error[E0277]: the trait bound `*const str: diesel::deserialize::FromSql&lt;diesel::sql_types::Integer, diesel::pg::Pg&gt;` is not satisfied
  --&gt; src/main.rs:34:63
   |
34 |     let s: Vec&lt;String&gt; = students::table.select(students::id).load(&amp;conn)?;
   |                                                               ^^^^ the trait `diesel::deserialize::FromSql&lt;diesel::sql_types::Integer, diesel::pg::Pg&gt;` is not implemented for `*const str`
   = help: the following implementations were found:
             &lt;*const [u8] as diesel::deserialize::FromSql&lt;diesel::sql_types::Binary, DB&gt;&gt;
             &lt;*const str as diesel::deserialize::FromSql&lt;diesel::sql_types::Text, DB&gt;&gt;
   = note: required because of the requirements on the impl of `diesel::deserialize::FromSql&lt;diesel::sql_types::Integer, diesel::pg::Pg&gt;` for `std::string::String`</code></pre>
<aside class="notes">
<ul>
<li><code>*const str</code> because that’s what we to impl <code>FromSql</code> for <code>String</code> internally</li>
<li>Mentioning the sql types as first type parameter, the backend as second.</li>
<li>There is only a limited set of valid mappings. (In this case mapping a <code>Integer</code> to a <code>String</code> does not make any sense)</li>
<li>Some type mappings are only supported for certain backends (<code>Uuid</code> for example)</li>
</ul>
</aside>
</section>
<section id="current-shortcomings-of-diesel" class="slide level2">
<h2>Current shortcomings of Diesel</h2>
<ul>
<li>No support for <code>GROUP BY</code> clauses and mixing aggregating and non aggregating expressions</li>
<li>Diesel expects to know at least the following things about <code>SELECT</code> statements at compile time:
<ul>
<li>Number of returned fields</li>
<li>SQL type of each returned field</li>
</ul></li>
<li>Writing code abstracting over Diesel can be challanging</li>
</ul>
<aside class="notes">
<ul>
<li>We are planing to address some of this points with the next diesel release</li>
<li>We will explore some of those points in greater detail later in our workshop</li>
</ul>
</aside>
</section>
<section id="building-a-first-simple-example" class="slide level2">
<h2>Building a first simple example</h2>
<ul>
<li>We want to build a simple blog backend</li>
<li>Today as REST API, Tomorrow as GraphQL API</li>
<li>Schema consists of 3 Tables:
<ul>
<li><code>users</code></li>
<li><code>posts</code></li>
<li><code>comments</code></li>
</ul></li>
<li>Project template at https://github.com/weiznich/wundergraph-workshop/</li>
</ul>
<aside class="notes">
<ul>
<li>work continuously on the project</li>
<li>Choose postgresql as database system, because we will do some advanced postgres function stuff later</li>
</ul>
</aside>
</section>
<section id="build-a-first-small-example" class="slide level2">
<h2>Build a first small example</h2>
<p><strong>Bootstrap a simple REST API for the given database schema:</strong></p>
<ol start="0" type="1">
<li>Clone the project template</li>
<li>Prepare the database by writing sql migrations for the given schema</li>
<li>Setup the database using <code>diesel_cli</code></li>
<li>Include the generated schema in your application</li>
<li>Expose CRUD operations for all 3 tables as REST API</li>
</ol>
<aside class="notes">
<ul>
<li>Required native dependencies for diesel (and diesel-cli):
<ul>
<li><code>libpq</code> + postgres installation for diesel with postgresql</li>
</ul></li>
<li>Use something like postman to test out your API</li>
<li>Time:</li>
<li>Feel free to call for help and ask questions</li>
<li>Need 1:30h + Break for second part today</li>
</ul>
</aside>
</section></section>
<section><section id="diesel-implementation-side" class="title-slide slide level1"><h1>Diesel (Implementation side)</h1><aside class="notes">
<ul>
<li>Talk about some “advance” diesel stuff
<ul>
<li>custom data types</li>
<li>dynamic queries</li>
<li>Abstract over queries</li>
</ul></li>
<li>Talk about some internals</li>
<li>Some of those stuff is not really present in our current documentation</li>
</ul>
</aside></section>
<section id="custom-types" class="slide level2">
<h2>Custom types</h2>
<ul>
<li>Diesel supports a set of commonly used types out of the box</li>
<li>Custom or uncommen SQL types require additional work</li>
<li>Diesel provides building blocks to easily add support for your own types</li>
</ul>
<aside class="notes">
<ul>
<li>We will cover a an example implementing a custom diesel type for a SQL enum in the next few slides</li>
<li>Example works similar for other types like mapping an enum to an existing data type or adding support for composite types</li>
</ul>
</aside>
</section>
<section id="custom-types-1" class="slide level2">
<h2>Custom types</h2>
<div class="sourceCode" id="cb23"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">CREATE</span> <span class="kw">TYPE</span> color <span class="kw">AS</span> ENUM (<span class="st">&#39;red&#39;</span>, <span class="st">&#39;green&#39;</span>, <span class="st">&#39;blue&#39;</span>);</span></code></pre></div>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1"></a><span class="at">#[</span>derive<span class="at">(</span>SqlType<span class="at">,</span> QueryId<span class="at">)]</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="at">#[</span>postgres<span class="at">(</span>type_name <span class="at">=</span> <span class="st">&quot;color&quot;</span><span class="at">)]</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">struct</span> ColorType;</span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="at">#[</span>derive<span class="at">(</span>FromSqlRow<span class="at">,</span> AsExrpession<span class="at">)]</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="at">#[</span>sql_type <span class="at">=</span> <span class="st">&quot;ColorType&quot;</span><span class="at">]</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="kw">enum</span> Color <span class="op">{</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>    Red,</span>
<span id="cb24-9"><a href="#cb24-9"></a>    Green,</span>
<span id="cb24-10"><a href="#cb24-10"></a>    Blue,</span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li>First snipped defines type on sql side</li>
<li>The first type is a representation of the sql type on rust side
<ul>
<li>Used as marker type to represent the type of an expression (more on that later)</li>
</ul></li>
<li>The second type is used to actually hold the value on rust side</li>
</ul>
</aside>
</section>
<section id="custom-types-2" class="slide level2">
<h2>Custom types</h2>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">impl</span> FromSql&lt;ColorType, Pg&gt; <span class="kw">for</span> Color <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>    <span class="kw">fn</span> from_sql(bytes: <span class="dt">Option</span>&lt;&amp;<span class="op">[</span><span class="dt">u8</span><span class="op">]</span>&gt;) -&gt; <span class="dt">Result</span>&lt;<span class="kw">Self</span>&gt; <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>        <span class="kw">match</span> bytes <span class="op">{</span></span>
<span id="cb25-4"><a href="#cb25-4"></a>            <span class="cn">Some</span>(<span class="st">b&quot;red&quot;</span>) =&gt; <span class="cn">Ok</span>(<span class="pp">Color::</span>Red),</span>
<span id="cb25-5"><a href="#cb25-5"></a>            <span class="cn">Some</span>(<span class="st">b&quot;green&quot;</span>) =&gt; <span class="cn">Ok</span>(<span class="pp">Color::</span>Green),</span>
<span id="cb25-6"><a href="#cb25-6"></a>            <span class="cn">Some</span>(<span class="st">b&quot;blue&quot;</span>) =&gt; <span class="cn">Ok</span>(<span class="pp">Color::</span>Blue),</span>
<span id="cb25-7"><a href="#cb25-7"></a>            _ =&gt; <span class="cn">Err</span>(<span class="st">&quot;Unrecognized enum variant&quot;</span>.into())</span>
<span id="cb25-8"><a href="#cb25-8"></a>        <span class="op">}</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>    <span class="op">}</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="op">}</span></span>
<span id="cb25-11"><a href="#cb25-11"></a></span>
<span id="cb25-12"><a href="#cb25-12"></a><span class="kw">impl</span> ToSql&lt;ColorType, Pg&gt; Color <span class="op">{</span></span>
<span id="cb25-13"><a href="#cb25-13"></a>    <span class="kw">fn</span> to_sql&lt;W: Write&gt;(&amp;<span class="kw">self</span>, out: &amp;<span class="kw">mut</span> Output&lt;W, Pg&gt;) -&gt; <span class="dt">Result</span>&lt;IsNull&gt; <span class="op">{</span></span>
<span id="cb25-14"><a href="#cb25-14"></a>         <span class="kw">match</span> *<span class="kw">self</span> <span class="op">{</span></span>
<span id="cb25-15"><a href="#cb25-15"></a>             <span class="pp">Color::</span>Red =&gt; out.write_all(<span class="st">b&quot;red&quot;</span>)?;,</span>
<span id="cb25-16"><a href="#cb25-16"></a>             <span class="pp">Color::</span>Green =&gt; out.write_all(<span class="st">b&quot;green&quot;</span>)?;</span>
<span id="cb25-17"><a href="#cb25-17"></a>             <span class="pp">Color::</span>Blue =&gt; out.write_all(<span class="st">b&quot;blue&quot;</span>)?;</span>
<span id="cb25-18"><a href="#cb25-18"></a>         <span class="op">}</span></span>
<span id="cb25-19"><a href="#cb25-19"></a>         <span class="cn">Ok</span>(<span class="pp">IsNull::</span>No)</span>
<span id="cb25-20"><a href="#cb25-20"></a>    <span class="op">}</span></span>
<span id="cb25-21"><a href="#cb25-21"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li>That’s the place where we tell Diesel how those types look at database protocol level.</li>
<li>Representation unfortunately not really documented, basically do what libpq does (for postgresql):</li>
<li>Strategies:
<ul>
<li>Enums: Just a binary text blob of the specific variant</li>
<li>Custom type mappings: Reuse existing mappings</li>
<li>Composit types: There are helper types inside of diesel (<code>Record</code>). Just use the generic impl of those types</li>
</ul></li>
</ul>
</aside>
</section>
<section id="fundamental-traits" class="slide level2">
<h2>Fundamental traits</h2>
<ul>
<li>Want to talk about a bit how Diesel queries work internally</li>
<li>Answer the following questions:
<ul>
<li>How does diesel build SQL from the query dsl?</li>
<li>How does diesel check queries at compile time?</li>
<li>How does a diesel query compose from simpler query fragments?</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Use some simplified examples, real one a bit more complex (but uses same idea)</li>
<li>Expect a hand full of non trivial trait bounds</li>
</ul>
</aside>
</section>
<section id="fundamental-traits-backend" class="slide level2">
<h2>Fundamental traits (Backend)</h2>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">trait</span> Backend <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>    <span class="kw">type</span> RawValue;</span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>Central definition of a supported database</li>
<li><code>RawValue</code> says which how data are represented at protocol level</li>
<li>Implementations are just zero sized marker types</li>
</ul>
<aside class="notes">
<ul>
<li>Fundamental trait, because used by nearly all other types/traits</li>
<li>There is also a <code>Connection</code> trait used to actual interact with the database, but that’s not interesting for query building and type checking.</li>
<li>Real one has some more associated types</li>
<li><code>RawValue</code> relevant for the definition of <code>FromSql</code>/<code>ToSql</code> we have seen before</li>
</ul>
</aside>
</section>
<section id="fundamental-traits-queryfragment" class="slide level2">
<h2>Fundamental traits (QueryFragment)</h2>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">trait</span> QueryFragment&lt;DB: Backend&gt; <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>    <span class="kw">fn</span> walk_ast(&amp;<span class="kw">self</span>, pass: AstPass&lt;DB&gt;) -&gt; QueryResult&lt;()&gt;;</span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>Trait indicating that some type could be translated to SQL.</li>
<li>Used to construct the final query</li>
<li>Helps to do most of the work at compile time</li>
</ul>
<aside class="notes">
<ul>
<li>Example implementation on the next slide</li>
<li><code>AstPass</code> is a helper type that abstracts over different use cases of calling <code>walk_ast</code>:
<ul>
<li>Generating the final SQL query</li>
<li>Collecting bound values</li>
<li>Determine if it is safe to cache the current query in the prepared statement cache</li>
</ul></li>
<li>Possible to implement that trait for all backends or only for a specific one</li>
<li>Allows to support backend specific features easily</li>
</ul>
</aside>
</section>
<section id="fundamental-traits-queryfragment-1" class="slide level2">
<h2>Fundamental traits (QueryFragment)</h2>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">struct</span> <span class="bu">Eq</span>&lt;L, R&gt;<span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>    left: L,</span>
<span id="cb28-3"><a href="#cb28-3"></a>    right: R,</span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="op">}</span></span>
<span id="cb28-5"><a href="#cb28-5"></a></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="kw">impl</span>&lt;L, R&gt; QueryFragment&lt;Pg&gt; <span class="kw">for</span> <span class="bu">Eq</span>&lt;L, R&gt;</span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="kw">where</span></span>
<span id="cb28-8"><a href="#cb28-8"></a>    L: QueryFragment&lt;Pg&gt;,</span>
<span id="cb28-9"><a href="#cb28-9"></a>    R: QueryFragment&lt;Pg&gt;,</span>
<span id="cb28-10"><a href="#cb28-10"></a><span class="op">{</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>    <span class="kw">fn</span> walk_ast(&amp;<span class="kw">self</span>, <span class="kw">mut</span> pass: AstPass&lt;DB&gt;) -&gt; QueryResult&lt;()&gt; <span class="op">{</span></span>
<span id="cb28-12"><a href="#cb28-12"></a>        <span class="kw">self</span>.left.walk_ast(pass.reborrow())?;</span>
<span id="cb28-13"><a href="#cb28-13"></a>        pass.push_sql(<span class="st">&quot; = &quot;</span>);</span>
<span id="cb28-14"><a href="#cb28-14"></a>        <span class="kw">self</span>.right.walk_ast(pass.reborrow())?;</span>
<span id="cb28-15"><a href="#cb28-15"></a>        <span class="cn">Ok</span>(())</span>
<span id="cb28-16"><a href="#cb28-16"></a>    <span class="op">}</span></span>
<span id="cb28-17"><a href="#cb28-17"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li>Will use that example query node also for later examples</li>
<li><code>left</code> represents the expression left of the equal sign, <code>right</code> the expression right of the sign</li>
<li>Also possible to impl for all backends (only useful for fundamental SQL expressions like <code>Eq</code>)</li>
<li><code>AstPass</code> exposes methods to append sql, a bind parameter or a identifier (See docs for details)</li>
<li>As long as no <code>dyn QueryFragment&lt;Pg&gt;</code> is involved <code>L</code> and <code>R</code> will be known at compile time -&gt; <code>walk_ast</code> calls to children will be inlined -&gt; query construction done mostly at compile time</li>
</ul>
</aside>
</section>
<section id="fundamental-traits-queryid" class="slide level2">
<h2>Fundamental traits (QueryId)</h2>
<div class="sourceCode" id="cb29"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">trait</span> QueryId <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>     <span class="kw">type</span> QueryId: Any;</span>
<span id="cb29-3"><a href="#cb29-3"></a>     <span class="kw">const</span> HAS_STATIC_QUERY_ID: <span class="dt">bool</span>;</span>
<span id="cb29-4"><a href="#cb29-4"></a>     <span class="kw">fn</span> query_id() -&gt; <span class="dt">Option</span>&lt;TypeId&gt; <span class="op">{}</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="op">}</span></span>
<span id="cb29-6"><a href="#cb29-6"></a></span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="kw">impl</span>&lt;L, R&gt; QueryId <span class="kw">for</span> <span class="bu">Eq</span>&lt;L, R&gt;</span>
<span id="cb29-8"><a href="#cb29-8"></a><span class="kw">where</span> L: QueryId, R: QueryId</span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="op">{</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>    <span class="kw">type</span> QueryId = <span class="kw">Self</span>;</span>
<span id="cb29-11"><a href="#cb29-11"></a>    <span class="kw">const</span> HAS_STATIC_QUERY_ID: <span class="dt">bool</span> =</span>
<span id="cb29-12"><a href="#cb29-12"></a>       <span class="pp">L::</span>HAS_STATIC_QUERY_ID &amp;&amp; <span class="pp">R::</span>HAS_STATIC_QUERY_ID;</span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="op">}</span></span></code></pre></div>
<div>
<ul>
<li class="fragment">Used to optimize the prepared statement cache</li>
<li class="fragment">Calculate <code>TypeId</code> of the composite type, use that as static prepared statement cache key</li>
</ul>
</div>
<aside class="notes">
<ul>
<li>This one is about optimisations</li>
<li>Should be implemented whenever you implement <code>QueryFragment</code>.</li>
<li>There is a derive for this (assumes <code>HAS_STATIC_QUERY_ID = true</code>)</li>
<li>ORM’s/query builder/db libs using prepared statements to skip reparsing the same query again and again</li>
<li>DB libs requiring you do handle prepared statements explicitly, ORM’s/query builder will that do for you</li>
<li>Use a prepared statement cache, which is basically a map Query -&gt; prepared statement handle</li>
<li>Question: How do we determine the key for our map?
<ul>
<li>Just use the SQL query string?
<ul>
<li>Now we need to construct the SQL on each call.</li>
<li>Could we do better?</li>
</ul></li>
<li>The query is represented by static types, known at compile time. Each query is composed from a different set of types.</li>
<li><code>Any</code> exposes a <code>TypeId</code> that is guaranteed to be unique and stable for unique types inside of an execution of a rust program
<ul>
<li>Not necessarily stable between different program executions, but that’s fine for this use case</li>
</ul></li>
</ul></li>
<li>Opt-Out for cases where different queries (different sql) are generated for the same data structure (<code>HAS_STATIC_QUERY_ID = false</code>, <code>TypeId = ()</code> in this case)</li>
</ul>
</aside>
</section>
<section id="fundamental-traits-expression" class="slide level2">
<h2>Fundamental traits (Expression)</h2>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1"></a><span class="kw">pub</span> <span class="kw">trait</span> Expression <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>    <span class="kw">type</span> SqlType;</span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="op">}</span></span>
<span id="cb30-4"><a href="#cb30-4"></a></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="kw">impl</span>&lt;L, R&gt; Expression <span class="kw">for</span> <span class="bu">Eq</span>&lt;L, R&gt; <span class="op">{</span></span>
<span id="cb30-6"><a href="#cb30-6"></a>    <span class="kw">type</span> SqlType = Bool;</span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>A marker trait representing a typed SQL fragment</li>
<li>Used for type checking the final query</li>
</ul>
<aside class="notes">
<ul>
<li>Trait used to calculate the sql type of an expression/query/</li>
<li>Basic component of type checking queries and match return types</li>
<li>You don’t need to implement that trait normally</li>
</ul>
</aside>
</section>
<section id="expanded-example-query" class="slide level2">
<h2>Expanded example query</h2>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1"></a><span class="pp">students::</span>table.filter(<span class="pp">students::</span>id.eq(<span class="dv">42</span>)).select(<span class="pp">students::</span>id)</span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1"></a>SelectStatement&lt;</span>
<span id="cb32-2"><a href="#cb32-2"></a>    <span class="pp">students::</span>table, <span class="co">// The table type, indicating the from clause</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    SelectClause&lt;<span class="pp">students::</span>id&gt;, <span class="co">// The select clause</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    WhereClause&lt;<span class="bu">Eq</span>&lt;<span class="pp">students::</span>id, Bound&lt;<span class="dt">i32</span>, Integer&gt;&gt;&gt;, <span class="co">// The where clause</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>    <span class="co">// Skipped some more parameters for other clauses</span></span>
<span id="cb32-6"><a href="#cb32-6"></a>&gt;</span></code></pre></div>
<div class="fragment">
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1"></a>Select&lt;</span>
<span id="cb33-2"><a href="#cb33-2"></a>    Filter&lt;<span class="pp">students::</span>table, <span class="bu">Eq</span>&lt;<span class="pp">students::</span>id, <span class="dt">i32</span>&gt;&gt;,</span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="pp">students::</span>id</span>
<span id="cb33-4"><a href="#cb33-4"></a>&gt;</span></code></pre></div>
<aside class="notes">
<ul>
<li><p>Each query expands to a unique type, depending on the actual query, similar to <code>Iterator</code></p></li>
<li><p>Expanded example uses internal types that are not meant to be used outside of diesel itself</p></li>
<li><p><code>diesel::dsl</code> provides nice wrapper types</p></li>
<li><p>So what consequences does this have?</p>
<ul>
<li>There is no single type to represent a query, each <code>QueryDsl</code> method call changes</li>
<li>Hard/Impossible to build query conditionally based on some dynamic condition (Talk about this soon)</li>
<li>Hard to write generically code performs <code>QueryDsl</code> manipulations. Need to ensure for each step that the corresponding query dsl sub trait is implemented for the type -&gt; rather lengthy bounds in where clauses</li>
</ul></li>
</ul>
</aside>
</div>
</section>
<section id="conditional-queries" class="slide level2">
<h2>Conditional queries</h2>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1"></a></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="kw">let</span> <span class="kw">mut</span> query = <span class="pp">students::</span>table.select(<span class="pp">students::</span>name);</span>
<span id="cb34-3"><a href="#cb34-3"></a></span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(id) = filter_by_id <span class="op">{</span></span>
<span id="cb34-5"><a href="#cb34-5"></a>    query = query.filter(<span class="pp">students::</span>id.eq(id));</span>
<span id="cb34-6"><a href="#cb34-6"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>Does not work because the query with filter has a different type than the query without filter</li>
</ul>
<aside class="notes">
<ul>
<li>How to solve this?</li>
<li>Diesel comes with a type that erases most of the generic select statement arguments</li>
</ul>
</aside>
</section>
<section id="conditional-queries-1" class="slide level2">
<h2>Conditional queries</h2>
<div class="sourceCode" id="cb35"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">let</span> <span class="kw">mut</span> query = <span class="pp">students::</span>table.select(<span class="pp">students::</span>name)</span>
<span id="cb35-2"><a href="#cb35-2"></a>     .into_boxed();</span>
<span id="cb35-3"><a href="#cb35-3"></a></span>
<span id="cb35-4"><a href="#cb35-4"></a><span class="kw">if</span> <span class="kw">let</span> <span class="cn">Some</span>(id) = filter_by_id <span class="op">{</span></span>
<span id="cb35-5"><a href="#cb35-5"></a>    query = query.filter(<span class="pp">students::</span>id.eq(id));</span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><code>.into_boxed</code> creates a boxed select statement that erases all generic arguments beside of the table name and target backend for the given select statement</li>
</ul>
<aside class="notes">
<ul>
<li>Similar to <code>Box&lt;dyn Iterator&gt;</code> instead of a complex composed iterator type</li>
<li>remaining generic arguments are required because:
<ul>
<li>table -&gt; check if table of column is in where clause</li>
<li>backend -&gt; check if sql is valid for backend</li>
</ul></li>
<li>Downsides:
<ul>
<li>comes with a performance penalty:
<ul>
<li>requires a few heap allocations</li>
<li>prevents some possible inlining while building the final query</li>
<li></li>
</ul></li>
</ul></li>
</ul>
</aside>
</section>
<section id="extending-our-example" class="slide level2">
<h2>Extending our example:</h2>
<ul>
<li>Add a column to the <code>post</code> table indicating the state of the post.
<ul>
<li>Represented as Enum on rust and postgresql side. Values <code>Draft</code>, <code>Published</code>, <code>Deleted</code></li>
</ul></li>
<li>Add a route that performs custom filter/order operations based on the query string of the route
<ul>
<li>Something like <code>http://localhost/posts?name="foo"&amp;order="id"</code></li>
</ul></li>
</ul>
</section>
<section id="extending-our-example-1" class="slide level2">
<h2>Extending our example</h2>
<ul>
<li>Add a route that performs allows to pagination on the <code>post</code> table
<ul>
<li>We want <code>http://localhost/posts/page/$page_number?post_count=$postcount</code> to return the number of total pages and the posts of the requested page.</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Try to implement that as custom query dsl node resolving the whole request using one query.</li>
<li>Hints:
<ul>
<li>For the pagination case:
<ul>
<li>Try to find some raw sql query that does what you want</li>
<li>Create a custom query dsl node</li>
<li>Need to implement <code>QueryFragment</code> , <code>QueryId</code>, <code>Query</code>, <code>RunQueryDsl</code> and a custom extension trait to be able to apply pagination to arbitrary queries</li>
</ul></li>
</ul></li>
</ul>
</aside>
</section></section>
<section><section id="wundergraph" class="title-slide slide level1"><h1>Wundergraph</h1></section>
<section id="graphql" class="slide level2">
<h2>GraphQL</h2>
<ul>
<li>A query language for API</li>
</ul>
<pre class="graphql"><code>{
    Teachers {
        teacherName: name
        students {
            name
        }
    }
}</code></pre>
<aside class="notes">
<ul>
<li>Tries to solve certain short comings of real world REST apis
<ul>
<li>There is an explicit typed schema</li>
<li>Schema introspection supported by default</li>
<li>Allows to request data in the format you need them, rather how the API specifies</li>
</ul></li>
</ul>
</aside>
</section>
<section id="what-is-wundergraph" class="slide level2">
<h2>What is wundergraph</h2>
<ul>
<li>Wundergraph is a crate that helps you with developing a diesel/juniper based GraphQL service in rust</li>
<li>Enables easy integration of diesel and juniper</li>
<li>Provides building blocks for writing GraphQL interfaces on top of relational database</li>
</ul>
<aside class="notes">
<ul>
<li>Unlocks writing performant GraphQL API based on relational databases in rust</li>
</ul>
</aside>
</section>
<section id="juniper" class="slide level2">
<h2>Juniper</h2>
<ul>
<li>Foundational crate for writing GraphQL APIs in rust</li>
<li>Independ from the actual data source</li>
<li>Provides foundational building blocks and helper APIs</li>
</ul>
<aside class="notes">
<ul>
<li>Short example on the next slide</li>
</ul>
</aside>
</section>
<section id="juniper-1" class="slide level2">
<h2>Juniper</h2>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1"></a><span class="at">#[</span>derive<span class="at">(</span>GraphQLObject<span class="at">)]</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb37-4"><a href="#cb37-4"></a>    name: <span class="dt">String</span>,</span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="op">}</span></span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="kw">struct</span> Query;</span>
<span id="cb37-8"><a href="#cb37-8"></a></span>
<span id="cb37-9"><a href="#cb37-9"></a><span class="pp">juniper::graphql_object!</span>(Query: Context |&amp;<span class="kw">self</span>| <span class="op">{</span></span>
<span id="cb37-10"><a href="#cb37-10"></a>    field apiVersion() -&gt; &amp;<span class="dt">str</span> <span class="op">{</span></span>
<span id="cb37-11"><a href="#cb37-11"></a>        <span class="st">&quot;1.0&quot;</span></span>
<span id="cb37-12"><a href="#cb37-12"></a>    <span class="op">}</span></span>
<span id="cb37-13"><a href="#cb37-13"></a></span>
<span id="cb37-14"><a href="#cb37-14"></a>    field student(&amp;executor, id: <span class="dt">i32</span>) -&gt; FieldResult&lt;Student&gt; <span class="op">{</span></span>
<span id="cb37-15"><a href="#cb37-15"></a>        <span class="kw">let</span> context = executor.context();</span>
<span id="cb37-16"><a href="#cb37-16"></a>        context.load_student_with_id(id)</span>
<span id="cb37-17"><a href="#cb37-17"></a>    <span class="op">}</span></span>
<span id="cb37-18"><a href="#cb37-18"></a><span class="op">}</span>);</span></code></pre></div>
<aside class="notes">
<ul>
<li>Simple example, see their docs for more complete examples</li>
<li>First struct registers a simple entity,
<ul>
<li>Runtime will return the correct fields if requested.</li>
<li>Assumes that you load the whole struct and the runtime selects the corresponding fields afterwards</li>
</ul></li>
<li>Marco registers a more complex entity
<ul>
<li>Named <code>Query</code> (That’s by convention the GraphQL root entity)</li>
<li>Register two fields: <code>apiVersion</code> and <code>student</code></li>
<li>Second field takes one argument on API side: <code>id</code></li>
<li>Both resolve functions can do arbitrary things:
<ul>
<li>First returns a constant value</li>
<li>Second does a database lookup (We will talk about the details in the next slide)</li>
</ul></li>
</ul></li>
</ul>
</aside>
</section>
<section id="diesel-juniper-naive-way" class="slide level2">
<h2>Diesel + Juniper (naive way)</h2>
<div class="sourceCode" id="cb38"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1"></a><span class="at">#[</span>derive<span class="at">(</span>GraphQLObject<span class="at">,</span> Queryable<span class="at">)]</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb38-4"><a href="#cb38-4"></a>    name: <span class="dt">String</span>,</span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="op">}</span></span>
<span id="cb38-6"><a href="#cb38-6"></a></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="at">#[</span>derive<span class="at">(</span>Queryable<span class="at">)]</span></span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="kw">struct</span> Teacher <span class="op">{</span></span>
<span id="cb38-9"><a href="#cb38-9"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb38-10"><a href="#cb38-10"></a>    name: <span class="dt">String</span>,</span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="op">}</span></span>
<span id="cb38-12"><a href="#cb38-12"></a></span>
<span id="cb38-13"><a href="#cb38-13"></a><span class="pp">juniper::graphql_object!</span>(Teacher: Context |&amp;<span class="kw">self</span>| <span class="op">{</span></span>
<span id="cb38-14"><a href="#cb38-14"></a>    field id() -&gt; <span class="dt">i32</span> <span class="op">{</span></span>
<span id="cb38-15"><a href="#cb38-15"></a>        <span class="kw">self</span>.id</span>
<span id="cb38-16"><a href="#cb38-16"></a>    <span class="op">}</span></span>
<span id="cb38-17"><a href="#cb38-17"></a></span>
<span id="cb38-18"><a href="#cb38-18"></a>    field name() -&gt; &amp;<span class="dt">str</span> <span class="op">{</span></span>
<span id="cb38-19"><a href="#cb38-19"></a>        &amp;<span class="kw">self</span>.name</span>
<span id="cb38-20"><a href="#cb38-20"></a>    <span class="op">}</span></span>
<span id="cb38-21"><a href="#cb38-21"></a></span>
<span id="cb38-22"><a href="#cb38-22"></a>    field students(&amp;executor) -&gt; FieldResult&lt;<span class="dt">Vec</span>&lt;Student&gt;&gt; <span class="op">{</span></span>
<span id="cb38-23"><a href="#cb38-23"></a>        <span class="kw">let</span> conn = executor.context().pool.get_connection()?;</span>
<span id="cb38-24"><a href="#cb38-24"></a></span>
<span id="cb38-25"><a href="#cb38-25"></a>        <span class="kw">let</span> students = <span class="pp">students::</span>table</span>
<span id="cb38-26"><a href="#cb38-26"></a>           .filter(<span class="pp">students::</span>supervisor.eq(<span class="kw">self</span>.id))</span>
<span id="cb38-27"><a href="#cb38-27"></a>           .<span class="pp">load::</span>&lt;Student&gt;(&amp;conn)?;</span>
<span id="cb38-28"><a href="#cb38-28"></a></span>
<span id="cb38-29"><a href="#cb38-29"></a>        <span class="cn">Ok</span>(students)</span>
<span id="cb38-30"><a href="#cb38-30"></a>    <span class="op">}</span></span>
<span id="cb38-31"><a href="#cb38-31"></a><span class="op">}</span>)</span></code></pre></div>
<aside class="notes">
<ul>
<li>Similar to the previous example, but now with two related entities</li>
<li>Schema required to resolve the example query from few slides before</li>
<li><code>Student</code> is a simplistic graphql type. Real world case would have an additional teacher field on student. that would require also a manual implementation similar to <code>Teacher</code></li>
<li><code>Teacher</code> is basically a simplistic graphql type beside of the <code>students</code> field.
<ul>
<li>first two field doing the same as the automatically derived implementation</li>
<li><code>students</code> grab a connection from the <code>context</code> (== global state) and query the database using a normal diesel query to load all students associated with a given teacher</li>
</ul></li>
<li>Problems?
<ul>
<li>N + 1 Query problem as soon as you request all teachers with their students
<ul>
<li>Bad for performance</li>
<li>Problem grows exponentially as soon as you add another level of nesting</li>
</ul></li>
<li>Loads data that are not required to answer a potential request
<ul>
<li>Our example does not request the student id, but this implementation will load it anyway</li>
<li>Not really important if the field is small, becomes impotent if a field contains a non trivial amount of data (Think of a blog post )</li>
</ul></li>
</ul></li>
</ul>
</aside>
</section>
<section id="problems-with-the-naive-way" class="slide level2">
<h2>Problems with the naive way</h2>
<ul>
<li>N + 1 Query problems</li>
<li>Loads data not required to answer the request</li>
<li>Adding options to filter/order/limit non trivial to add</li>
</ul>
<aside class="notes">
<ul>
<li>How to solve this?</li>
<li>Two possible “classic” solutions:
<ul>
<li>“Eager Loading”: Just add a layer of caching/query post processing before actually executing those queries
<ul>
<li>Instead of loading each student on it’s own batch those call to do the loading afterwards</li>
</ul></li>
<li>LookAhead: Instead of only looking at the current part of the request look at the whole request and build a fixed number of queries to answer the whole request
<ul>
<li>For the N+1 problem this means we are just collecting all the teacher id’s into a list, load all matching students in a single query and then do the matching on rust side</li>
</ul></li>
</ul></li>
</ul>
</aside>
</section>
<section id="wundergraph-example" class="slide level2">
<h2>Wundergraph Example</h2>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1"></a><span class="at">#[</span>derive<span class="at">(</span>Identifiable<span class="at">,</span> WundergraphEntity<span class="at">)]</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;students&quot;</span><span class="at">]</span></span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb39-4"><a href="#cb39-4"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb39-5"><a href="#cb39-5"></a>    name: <span class="dt">String</span>,</span>
<span id="cb39-6"><a href="#cb39-6"></a>    supervisor: HasOne&lt;<span class="dt">i32</span>, Teacher&gt;,</span>
<span id="cb39-7"><a href="#cb39-7"></a><span class="op">}</span></span>
<span id="cb39-8"><a href="#cb39-8"></a></span>
<span id="cb39-9"><a href="#cb39-9"></a><span class="at">#[</span>derive<span class="at">(</span>Identifiable<span class="at">,</span> WundergraphEntity<span class="at">)]</span></span>
<span id="cb39-10"><a href="#cb39-10"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;teachers&quot;</span><span class="at">]</span></span>
<span id="cb39-11"><a href="#cb39-11"></a><span class="kw">struct</span> Teacher <span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb39-13"><a href="#cb39-13"></a>    name: <span class="dt">String</span>,</span>
<span id="cb39-14"><a href="#cb39-14"></a>    students: HasMany&lt;Student, <span class="pp">students::</span>supervisor&gt;,</span>
<span id="cb39-15"><a href="#cb39-15"></a><span class="op">}</span></span>
<span id="cb39-16"><a href="#cb39-16"></a></span>
<span id="cb39-17"><a href="#cb39-17"></a><span class="pp">wundergraph::query_object!</span> <span class="op">{</span></span>
<span id="cb39-18"><a href="#cb39-18"></a>    Query <span class="op">{</span></span>
<span id="cb39-19"><a href="#cb39-19"></a>        Student,</span>
<span id="cb39-20"><a href="#cb39-20"></a>        Teacher</span>
<span id="cb39-21"><a href="#cb39-21"></a>    <span class="op">}</span></span>
<span id="cb39-22"><a href="#cb39-22"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li><p>Structs just define the data layout of the graphql entities</p></li>
<li><p>Talk about each part a bit more in detail in the next few slides</p></li>
<li><p>Will talk about the internal implementation of all of this later today</p></li>
<li><p>What is generated for you in the background:</p></li>
</ul>
</aside>
</section>
<section id="wundergraphentity" class="slide level2">
<h2><code>WundergraphEntity</code></h2>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1"></a><span class="at">#[</span>derive<span class="at">(</span>WundergraphEntity<span class="at">,</span> Identifiable<span class="at">)]</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;student&quot;</span><span class="at">]</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="at">#[</span>primary_key<span class="at">(</span>id<span class="at">)]</span></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="co">/// GraphQL type description</span></span>
<span id="cb40-5"><a href="#cb40-5"></a><span class="kw">struct</span> Student <span class="op">{</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>    <span class="co">/// GraphQL field description</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb40-8"><a href="#cb40-8"></a>    <span class="at">#[</span>wundergraph<span class="at">(</span>graphql_name <span class="at">=</span> <span class="st">&quot;name&quot;</span><span class="at">)]</span></span>
<span id="cb40-9"><a href="#cb40-9"></a>    <span class="at">#[</span>column_name <span class="at">=</span> <span class="st">&quot;name&quot;</span><span class="at">]</span></span>
<span id="cb40-10"><a href="#cb40-10"></a>    name: <span class="dt">String</span>,</span>
<span id="cb40-11"><a href="#cb40-11"></a>    supervisor: HasOne&lt;<span class="dt">i32</span>, Teacher&gt;,</span>
<span id="cb40-12"><a href="#cb40-12"></a>    papers: HasMany&lt;Paper, <span class="pp">papers::</span>student&gt;,</span>
<span id="cb40-13"><a href="#cb40-13"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>Marks a type as compatible wundergraph entity</li>
<li>Controls corresponding GraphQL type</li>
<li>Field names map directly to corresponding columns in table</li>
</ul>
<aside class="notes">
<ul>
<li>All structs deriving <code>Wundergraphentity</code> require deriving <code>Identifiable</code> (or implementing <code>Identifiable</code> + <code>HasTable</code>)</li>
<li>Each field maps to a database table column (there is <code>#[column_name = "foo"]</code> to make this explicit, otherwise name is used)</li>
<li>Special field types indicating some kind of relation ship:
<ul>
<li><code>HasOne</code>: Indicates that the current entity is child to the given entity: (n:1)
<ul>
<li>First parameter: foreign key type</li>
<li>Second parameter: Parent type</li>
</ul></li>
<li><code>HasMany</code>: Indicates that the current entity is parent of a set of child entities: (1:n)
<ul>
<li>First parameter: Child type</li>
<li>Second parameter: foreign key on the child (required because there could be multiple relation ships to the same table)</li>
</ul></li>
</ul></li>
<li>Generates the following graphql:
<ul>
<li>A GraphQL type for each type deriving <code>WundergraphEntity</code> with the given field of those structs
<ul>
<li>“normal” field map directly to their graphql type</li>
<li><code>HasOne</code> just maps to the parent type as field type</li>
<li><code>HasMany</code> maps to a list of child types as field type</li>
</ul></li>
<li>A matching filter type that allows you to specify filters for each field and compose them (Just see the generated schema in our practical example later)</li>
</ul></li>
</ul>
</aside>
</section>
<section id="query_object" class="slide level2">
<h2><code>query_object!</code></h2>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1"></a><span class="pp">wundergraph::query_object!</span> <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2"></a>    <span class="co">/// GraphQL description for query</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>    Query <span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>        <span class="co">/// GraphQL description for Student</span></span>
<span id="cb41-5"><a href="#cb41-5"></a>        <span class="at">#[</span>deprecated<span class="at">(</span>note <span class="at">=</span> <span class="st">&quot;Why&quot;</span><span class="at">)]</span></span>
<span id="cb41-6"><a href="#cb41-6"></a>        Student,</span>
<span id="cb41-7"><a href="#cb41-7"></a>        <span class="at">#[</span>wundergraph<span class="at">(</span>filter <span class="at">=</span> <span class="cn">true</span><span class="at">,</span> offset <span class="at">=</span> <span class="cn">true</span><span class="at">,</span> order <span class="at">=</span> <span class="cn">true</span><span class="at">)]</span></span>
<span id="cb41-8"><a href="#cb41-8"></a>        Teacher,</span>
<span id="cb41-9"><a href="#cb41-9"></a>    <span class="op">}</span></span>
<span id="cb41-10"><a href="#cb41-10"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li>Generates the root “Query” object.</li>
<li>For each entity two field on the <code>Query</code> object are generated:
<ul>
<li>A field to query the entity by the primary key returning a single element
<ul>
<li>Will be named <code>Student</code> for the <code>Student</code> entity</li>
</ul></li>
<li>A field to query all entries returning a list of entities
<ul>
<li>Will be named <code>Students</code> for the <code>Student</code> entity</li>
<li>Allows to perform custom filter/order/offset/limit expression passed as argument</li>
</ul></li>
</ul></li>
<li><code>Query</code> names the object (other names possible)</li>
<li>Doc comments are mapped to field/type descriptions in the GraphQL schema</li>
<li><code>#[deprecated]</code> attributes are mapped to deprecated notices in the GraphQL schema</li>
<li><code>[#wundergraph]</code> attribute control which optional arguments are generated</li>
</ul>
</aside>
</section>
<section id="mutation" class="slide level2">
<h2>Mutation</h2>
<ul>
<li>Per convention there is a “special” mutation object in GraphQL schemas allowing to mutate data</li>
<li>Mutations are done by requesting a field on the mutation object and passing mutation data as arguments</li>
</ul>
<pre class="graphql"><code>mutation CreateStudent {
    createStudent(name: &quot;weiznich&quot;, supervisor: 42) {
        id
        name
    }
}</code></pre>
<aside class="notes">
<ul>
<li>data passed as arguments</li>
<li>need to say explicitly in our request that we are doing a mutation</li>
<li>“field” <code>createStudent</code> returns a normal <code>Student</code></li>
<li>return data specified as normal graphql requested fields</li>
</ul>
</aside>
</section>
<section id="mutation-implementation" class="slide level2">
<h2>Mutation (implementation)</h2>
<ul>
<li>Structs implementing …
<ul>
<li><code>Insertable</code> are automatically usable as insert mutation</li>
<li><code>AsChangeset</code> are automatically usable as update mutation</li>
</ul></li>
<li>Delete mutations are automatically provided via primary keys</li>
<li>Possible to manual implement custom behaviour by using corresponding traits in <code>wundergraph::query_builder::mutations</code></li>
</ul>
<aside class="notes">
<ul>
<li>Two ways of doing mutations:
<ul>
<li>Using “autogenerated” mutation objects by doing
<ul>
<li>insert via <code>Insertable</code></li>
<li>update via <code>AsChangeset</code></li>
<li>delete by primary key</li>
</ul></li>
</ul></li>
</ul>
</aside>
</section>
<section id="mutation-implementation-1" class="slide level2">
<h2>Mutation (implementation)</h2>
<div class="sourceCode" id="cb43"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1"></a><span class="at">#[</span>derive<span class="at">(</span>Insertable<span class="at">,</span> GraphQLInputObject<span class="at">)]</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;students&quot;</span><span class="at">]</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="kw">struct</span> NewStudent <span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4"></a>    name: <span class="dt">String</span>,</span>
<span id="cb43-5"><a href="#cb43-5"></a>    supervisor: <span class="dt">i32</span>,</span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="op">}</span></span>
<span id="cb43-7"><a href="#cb43-7"></a></span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="at">#[</span>derive<span class="at">(</span>AsChangeset<span class="at">,</span> Identifiable<span class="at">,</span> GraphQLInputObject<span class="at">)]</span></span>
<span id="cb43-9"><a href="#cb43-9"></a><span class="at">#[</span>table_name <span class="at">=</span> <span class="st">&quot;studens&quot;</span><span class="at">]</span></span>
<span id="cb43-10"><a href="#cb43-10"></a><span class="kw">struct</span> StudentChangeset <span class="op">{</span></span>
<span id="cb43-11"><a href="#cb43-11"></a>    id: <span class="dt">i32</span>,</span>
<span id="cb43-12"><a href="#cb43-12"></a>    name: <span class="dt">String</span></span>
<span id="cb43-13"><a href="#cb43-13"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="mutation_object" class="slide level2">
<h2><code>mutation_object!</code></h2>
<div class="sourceCode" id="cb44"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1"></a><span class="pp">wundergraph::mutation_object!</span> <span class="op">{</span></span>
<span id="cb44-2"><a href="#cb44-2"></a>    <span class="co">/// GraphQL description for mutation</span></span>
<span id="cb44-3"><a href="#cb44-3"></a>    Mutation <span class="op">{</span></span>
<span id="cb44-4"><a href="#cb44-4"></a>        Student(insert = NewStudent, update = StudentChangeset, delete = <span class="cn">true</span>),</span>
<span id="cb44-5"><a href="#cb44-5"></a>    <span class="op">}</span></span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li>Macro similar to <code>query_object!</code></li>
<li>Generates the “Mutation” object</li>
<li><code>Mutation</code> names the object (other names are possible)</li>
<li>Generates for each field (depending of the arguments):
<ul>
<li>an insert mutation field named <code>CreateStudent</code></li>
<li>a batch insert mutation field named <code>CreateStudents</code></li>
<li>a update mutation field named <code>UpdateStudent</code></li>
<li>a delete mutation field named <code>DeleteStudent</code></li>
</ul></li>
<li>Possible to disable single mutations by leaving of/passing <code>false</code> the corresponding arguments</li>
<li>Possible to pass a custom struct implementing the corresponding trait to delete instead for custom behaviour (instead of just having the primary keys as argument)</li>
</ul>
</aside>
</section>
<section id="custom-context" class="slide level2">
<h2>Custom Context</h2>
<ul>
<li>Wundergraph requires you to use a type that implements <code>WundergraphContext</code> as juniper context type</li>
<li>By default that’s implemented for all types that implement diesel’s <code>Connection</code> trait</li>
</ul>
<aside class="notes">
<ul>
<li><code>WundergraphContext</code> just tells wundergraph how to get a database connection out of given context</li>
</ul>
</aside>
</section>
<section id="querymodifier" class="slide level2">
<h2>QueryModifier</h2>
<div class="sourceCode" id="cb45"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">trait</span> QueryModifier&lt;L, DB&gt; <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>   <span class="kw">fn</span> modify_query(</span>
<span id="cb45-3"><a href="#cb45-3"></a>       &amp;<span class="kw">self</span>,</span>
<span id="cb45-4"><a href="#cb45-4"></a>       select: &amp;LookAheadSelection&lt;WundergraphScalarValue&gt;,</span>
<span id="cb45-5"><a href="#cb45-5"></a>       query: BoxedQuery&lt;L, DB, <span class="kw">Self</span>&gt;,</span>
<span id="cb45-6"><a href="#cb45-6"></a>   ) -&gt; <span class="dt">Result</span>&lt;BoxedQuery&lt;L, DB, <span class="kw">Self</span>&gt;&gt;;</span>
<span id="cb45-7"><a href="#cb45-7"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>A trait that allows you to get access to the final query before execution</li>
<li>Implemented for the context type, so you are required to use a custom context type if you want to use this trait</li>
<li>Entities passed as first type parameter</li>
</ul>
<aside class="notes">
<ul>
<li><p>required to have an implementation for all entities</p></li>
<li><p>Possible to use wild card impl or concrete implementation for each type</p></li>
<li><p>Use cases:</p>
<ul>
<li>Modify the constructed query by adding additional filters (For example to hide certain database entries based on access rights)</li>
<li>Completely abort request based on some custom information (Access control)</li>
</ul></li>
</ul>
</aside>
</section>
<section id="wundergraph-cli" class="slide level2">
<h2>Wundergraph CLI</h2>
<ul>
<li>Wundergraph CLI is a small CLI helper tool to generate struct definitions from an existing database</li>
<li>Works similar to diesel CLI</li>
<li>Generates for each database table:
<ul>
<li>A diesel <code>table!</code> macro call</li>
<li>A matching query entity</li>
<li>An insert type used for insert mutations</li>
<li>A changeset type used for update mutations</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Behaviour similar to diesel cli</li>
<li>Backends controlled by feature flags, enabled by default: sqlite + postgres</li>
<li>Everything registered with the <code>query_object!</code>/<code>mutation_object!</code> macro for final usage</li>
</ul>
</aside>
</section>
<section id="exercise" class="slide level2">
<h2>Exercise</h2>
<ul>
<li>Implement the REST API from our first exercise now as GraphQL API:
<ol start="0" type="1">
<li>Add juniper and wundergraph as dependency in your Cargo.toml</li>
<li>Add a juniper GraphQL endpoint to your application</li>
<li>Setup Query/Mutation entities for all three tables</li>
</ol></li>
<li>Note: Project template from yesterday at: https://github.com/weiznich/wundergraph-workshop/</li>
</ul>
<aside class="notes">
<ul>
<li>Juniper provides a build in way to register a endpoint to deliver a packed version of <code>GraphiQL</code> (interactive <code>GraphQL</code> testbed), use that for testing?</li>
</ul>
</aside>
</section></section>
<section><section id="wundergraph-implementation-side" class="title-slide slide level1"><h1>Wundergraph (Implementation side)</h1></section>
<section id="overview" class="slide level2">
<h2>Overview</h2>
<ul>
<li>Talk a bit about the implementation of wundergraph</li>
<li>Technical aspects</li>
<li>How to provide custom implementations</li>
</ul>
<aside class="notes">

</aside>
</section>
<section id="technical-challenges-using-diesel" class="slide level2">
<h2>Technical challenges using diesel</h2>
<ul>
<li>Diesel want’s to know the number of selected columns at compile time
<ul>
<li>Just select constant <code>NULL</code> instead of removing the field</li>
</ul></li>
<li>Arbitrary runtime joining between tables is not possible to implement using diesel
<ul>
<li>Use diesel <code>Associations</code> approach involving a fixed number of queries instead</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Number of fields is a runtime information an GraphQL</li>
<li>Selecting null not perfect, but “works”</li>
<li>A GraphQL request could involve more than one table due to nesting (== database relations)</li>
<li>Not literally <code>diesel::Associations</code> because of implementation details, but basically the same query</li>
</ul>
</aside>
</section>
<section id="technical-challenges-using-diesel-1" class="slide level2">
<h2>Technical challenges using diesel</h2>
<ul>
<li>Dynamic query construction in a generic case
<ul>
<li><code>BoxedSelectStatement</code> helps there, but writing generic code also required</li>
</ul></li>
<li>Diesel supports primitive types not supported by default as Juniper scalar values
<ul>
<li>Provide own Juniper scalar value implementation</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Unsupported by Juniper: <code>i64</code>, <code>i16</code>, …</li>
<li>Currently a fixed scalarvalue type named <code>WundergraphScalarValue</code></li>
</ul>
</aside>
</section>
<section id="loadinghandler" class="slide level2">
<h2>LoadingHandler</h2>
<div class="sourceCode" id="cb46"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">pub</span> <span class="kw">trait</span> LoadingHandler&lt;DB, Ctx&gt; : HasTable + <span class="bu">Sized</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="kw">where</span> DB: Backend</span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="op">{</span></span>
<span id="cb46-4"><a href="#cb46-4"></a>    <span class="kw">type</span> Columns;</span>
<span id="cb46-5"><a href="#cb46-5"></a>    <span class="kw">type</span> FieldList;</span>
<span id="cb46-6"><a href="#cb46-6"></a>    <span class="kw">type</span> PrimaryKeyIndex;</span>
<span id="cb46-7"><a href="#cb46-7"></a>    <span class="kw">type</span> Filter;</span>
<span id="cb46-8"><a href="#cb46-8"></a></span>
<span id="cb46-9"><a href="#cb46-9"></a>    <span class="kw">const</span> FIELD_NAMES: &amp;<span class="op">[</span>&amp;<span class="dt">str</span><span class="op">]</span>;</span>
<span id="cb46-10"><a href="#cb46-10"></a>    <span class="kw">const</span> TYPE_NAME: &amp;<span class="dt">str</span>;</span>
<span id="cb46-11"><a href="#cb46-11"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li>Central trait for querying GraphQL entities</li>
</ul>
<aside class="notes">
<ul>
<li><p>One of the traits automatically implemented while deriving <code>WundergraphEntity</code></p></li>
<li><p>Generic parameters:</p>
<ul>
<li><code>DB</code>: Backend type</li>
<li><code>Ctx</code> Context type</li>
</ul></li>
<li><p>Associated types: -<code>Columns</code>: Tuple of diesel column in the right order</p>
<ul>
<li><code>FieldList</code>: Tuple of the struct field types</li>
<li><code>PrimaryKeyIndex</code>: Type level index into a tuple,
<ul>
<li>addressing the primary key</li>
<li>basically <code>TupleIndexX</code> from <code>wundergraph::helper</code></li>
<li>Composite key use tuple instead</li>
</ul></li>
<li><code>Filter</code>: Used filter type. Use <code>()</code> to use no filter</li>
</ul></li>
<li><p>Consts:</p>
<ul>
<li><code>FIELD_NAMES</code>: List of all field names</li>
<li><code>TYPE_NAME</code> Name of the type</li>
</ul></li>
<li><p>Useful to implement that manually if the default implementation does not fit</p></li>
</ul>
</aside>
</section>
<section id="wundergraphbelongsto" class="slide level2">
<h2>WundergraphBelongsTo</h2>
<div class="sourceCode" id="cb47"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">pub</span> <span class="kw">trait</span> WundergraphBelongsTo&lt;Other, DB, Ctx, FK&gt;: LoadingHandler&lt;DB, Ctx&gt; <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>    <span class="kw">type</span> Key;</span>
<span id="cb47-3"><a href="#cb47-3"></a></span>
<span id="cb47-4"><a href="#cb47-4"></a>    <span class="kw">fn</span> resolve(</span>
<span id="cb47-5"><a href="#cb47-5"></a>        glob_args: &amp;<span class="op">[</span>LookAheadArgument&lt;WundergraphScalarValue&gt;<span class="op">]</span>,</span>
<span id="cb47-6"><a href="#cb47-6"></a>        look_ahead: &amp;<span class="op">[</span>LookAheadSelection&lt;WundergraphScalarValue&gt;<span class="op">]</span>,</span>
<span id="cb47-7"><a href="#cb47-7"></a>        selection: <span class="dt">Option</span>&lt;&amp;<span class="op">[</span>Selection&lt;WundergraphScalarValue&gt;<span class="op">]</span>,</span>
<span id="cb47-8"><a href="#cb47-8"></a>        keys: &amp;<span class="op">[</span><span class="dt">Option</span>&lt;<span class="kw">Self</span>::Key&gt;<span class="op">]</span>,</span>
<span id="cb47-9"><a href="#cb47-9"></a>        executor: Executor&lt;Ctx, WundergraphScalarValue&gt;,</span>
<span id="cb47-10"><a href="#cb47-10"></a>    ) -&gt; <span class="dt">Result</span>&lt;</span>
<span id="cb47-11"><a href="#cb47-11"></a>        HashMap&lt;</span>
<span id="cb47-12"><a href="#cb47-12"></a>            <span class="dt">Option</span>&lt;<span class="kw">Self</span>::Key&gt;,</span>
<span id="cb47-13"><a href="#cb47-13"></a>            <span class="dt">Vec</span>&lt;Value&lt;WundergraphScalarValue&gt;&gt;</span>
<span id="cb47-14"><a href="#cb47-14"></a>        &gt;&gt;;</span>
<span id="cb47-15"><a href="#cb47-15"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li><p>Need to be implemented for <code>HasOne</code> field in one of your structs</p></li>
<li><p>Each <code>HasMany</code> field needs a corresponding <code>HasOne</code> field due to this implementation</p></li>
<li><p>Just construct and execute the query, leave the construction of the result to <code>build_response</code></p></li>
<li><p>Required to be a backend specific implementation because otherwise rustc will yell at us about cyclic trait bounds</p></li>
<li><p>Also implemented by deriving <code>WundergraphEntity</code></p></li>
<li><p>Otherwise there exists a distinct derive</p></li>
</ul>
</aside>
</section>
<section id="filter-infrastructure" class="slide level2">
<h2>Filter infrastructure</h2>
<ul>
<li>Automatically generated for structs implementing <code>LoadingHandler</code></li>
<li>Composable out simple filters for each type</li>
</ul>
<div class="sourceCode" id="cb48"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">trait</span> FilterValue&lt;C&gt; <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2"></a>    <span class="kw">type</span> RawValue;</span>
<span id="cb48-3"><a href="#cb48-3"></a>    <span class="kw">type</span> AdditionalFilter;</span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li>implemented for concrete rust type</li>
<li>Means type support a default set (<code>eq</code> and other) of filter ops</li>
<li><code>RawValue</code> means the inner type
<ul>
<li>usual just self</li>
<li>For <code>Option&lt;T&gt;</code> or something like that <code>T</code></li>
</ul></li>
<li><code>AdditionalFilter</code> is a way to add more filter operations for a specific type
<ul>
<li>Example adding <code>like</code> for strings</li>
</ul></li>
</ul>
</aside>
</section>
<section id="tuple-mappers" class="slide level2">
<h2>Tuple mappers</h2>
<ul>
<li>Internally most of the things in wundergraph operate on tuples at a type level to generate things</li>
<li>Basic work flow:
<ul>
<li>Filter unwanted types for a tuple</li>
<li>Depending on the context generate juniper/diesel data structure from the tuple by mapping each “field” to a corresponding data field</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Filtering/Mapping just done by implementing a trait</li>
<li>Both done at compile time</li>
</ul>
</aside>
</section>
<section id="tuple-mappers-1" class="slide level2">
<h2>Tuple mappers</h2>
<div class="sourceCode" id="cb49"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">trait</span> ExtractTableFields <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>    <span class="kw">type</span> Out;</span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="op">}</span></span>
<span id="cb49-4"><a href="#cb49-4"></a></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="kw">impl</span>&lt;T1, T2&gt; ExtractTableFields <span class="kw">for</span> (T1, T2)</span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="kw">where</span> T1: WundergraphValue, (T2,): ExtractTableFields</span>
<span id="cb49-7"><a href="#cb49-7"></a>     &lt;(T2,) <span class="kw">as</span> ExtractTableFields&gt;::Out: AppendToTuple&lt;T1&gt;</span>
<span id="cb49-8"><a href="#cb49-8"></a><span class="op">{</span></span>
<span id="cb49-9"><a href="#cb49-9"></a>    <span class="kw">type</span> Out = &lt;&lt;(T2,) <span class="kw">as</span> ExtractTableFields&gt;::Out</span>
<span id="cb49-10"><a href="#cb49-10"></a>        <span class="kw">as</span> AppendToTuple&lt;T1&gt;&gt;::Out;</span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="op">}</span></span>
<span id="cb49-12"><a href="#cb49-12"></a></span>
<span id="cb49-13"><a href="#cb49-13"></a><span class="kw">impl</span>&lt;C, FK, T2&gt; ExtractTableFields <span class="kw">for</span> (HasMany&lt;C, FK&gt;, T2)</span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="kw">where</span> (T2,): ExtractTableFields</span>
<span id="cb49-15"><a href="#cb49-15"></a><span class="op">{</span></span>
<span id="cb49-16"><a href="#cb49-16"></a>    <span class="kw">type</span> Out = &lt;(T2,) <span class="kw">as</span> ExtractTableFields&gt;::Out;</span>
<span id="cb49-17"><a href="#cb49-17"></a><span class="op">}</span></span></code></pre></div>
<aside class="notes">
<ul>
<li>Provide such implementations for each (supported) tuple size</li>
</ul>
</aside>
</section>
<section id="final-exercise" class="slide level2">
<h2>Final exercise</h2>
<ul>
<li>We want to store different versions of the same post.
<ul>
<li>A version is represented as range of starting and ending version</li>
<li>Write a SQL function that could be used instead of the posts table in the from clause.
<ul>
<li><code>SELECT * FROM post_at_version(5);</code></li>
</ul></li>
<li>Integrate that in our GraphQL interface</li>
</ul></li>
</ul>
<aside class="notes">
<ul>
<li>Current version has <code>end_version = NULL</code></li>
<li>hints:
<ul>
<li>Need to look at the expanded output of <code>diesel::sql_function</code> and <code>diesel::table</code>, implement a combination</li>
<li>Need to manually implement <code>LoadingHandler</code> and similar traits</li>
<li>Macro to define a <code>table!</code> like structure is provided in the <code>diesel_ext.rs</code> module of the latest version of my solution
<ul>
<li>Have a look into it and try to understand what it is doing</li>
<li>(Not perfect but works at least for this exercise)</li>
</ul></li>
</ul></li>
</ul>
</aside>
</section></section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@3.9.2//js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'https://unpkg.com/reveal.js@3.9.2//lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'https://unpkg.com/reveal.js@3.9.2//plugin/zoom-js/zoom.js', async: true },
          { src: 'https://unpkg.com/reveal.js@3.9.2//plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
